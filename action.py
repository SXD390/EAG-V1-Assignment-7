from typing import List, Dict, Any, Union, Optional
import logging
import time
import ast
import re
from datetime import datetime
from pydantic import BaseModel
from mcp import ClientSession
from models import MemoryItem, SearchResult, ActionResult, DecisionResult, VideoSegment

# Configure logging
logging.basicConfig(level=logging.DEBUG, format='[%(asctime)s] [%(name)s] [%(levelname)s] %(message)s')
logger = logging.getLogger("yt_rag.action")

def log(stage: str, msg: str):
    """Log a message with timestamp and stage"""
    now = datetime.now().strftime("%H:%M:%S")
    logger.debug(f"[{now}] [{stage}] {msg}")

class ToolCallResult(BaseModel):
    """Result of a tool call"""
    tool_name: str
    arguments: Dict[str, Any]
    result: Union[str, list, dict]
    raw_response: Any

def parse_function_call(response: str) -> tuple[str, Dict[str, Any]]:
    """Parses FUNCTION_CALL string into tool name and arguments."""
    try:
        if not response.startswith("FUNCTION_CALL:"):
            raise ValueError("Not a valid FUNCTION_CALL")

        _, function_info = response.split(":", 1)
        parts = [p.strip() for p in function_info.split("|")]
        func_name, param_parts = parts[0], parts[1:]

        result = {}
        for part in param_parts:
            if "=" not in part:
                raise ValueError(f"Invalid param: {part}")
            key, value = part.split("=", 1)

            try:
                parsed_value = ast.literal_eval(value)
            except Exception:
                parsed_value = value.strip()

            # Handle nested keys
            keys = key.split(".")
            current = result
            for k in keys[:-1]:
                current = current.setdefault(k, {})
            current[keys[-1]] = parsed_value

        log("parser", f"Parsed: {func_name} → {result}")
        return func_name, result

    except Exception as e:
        log("parser", f"❌ Failed to parse FUNCTION_CALL: {e}")
        raise

class Action:
    """Generate response based on decision and memory items."""
    
    def __init__(self):
        """Initialize the action component."""
        log("action", "Initializing Action component")
        log("action", "Action component initialized")
    
    async def execute_tool(self, session: ClientSession, tools: list, response: str) -> ToolCallResult:
        """Executes a FUNCTION_CALL via MCP tool session."""
        try:
            tool_name, arguments = parse_function_call(response)

            tool = next((t for t in tools if t.name == tool_name), None)
            if not tool:
                raise ValueError(f"Tool '{tool_name}' not found in registered tools")

            # Fix for search_transcripts - wrap parameters in an input field
            mcp_arguments = arguments
            if tool_name == "search_transcripts":
                mcp_arguments = {"input": arguments}
                log("tool", f"Wrapping parameters for search_transcripts: {mcp_arguments}")

            log("tool", f"⚙️ Calling '{tool_name}' with: {mcp_arguments}")
            result = await session.call_tool(tool_name, arguments=mcp_arguments)

            if hasattr(result, 'content'):
                if isinstance(result.content, list):
                    out = [getattr(item, 'text', str(item)) for item in result.content]
                else:
                    out = getattr(result.content, 'text', str(result.content))
            else:
                out = str(result)

            log("tool", f"✅ {tool_name} result: {out}")
            return ToolCallResult(
                tool_name=tool_name,
                arguments=arguments,
                result=out,
                raw_response=result
            )

        except Exception as e:
            log("tool", f"⚠️ Execution failed for '{response}': {e}")
            raise
    
    def format_response(self, generated_text: str, memory_items: List[MemoryItem]) -> SearchResult:
        """Format the final response including generated text and sources.
        
        Args:
            generated_text: The text generated by the decision component
            memory_items: The memory items used to generate the response
            
        Returns:
            A SearchResult object with answer and sources
        """
        log("action", "Formatting response with sources")
        
        # Extract video segments from memory items
        all_segments = []
        for item in memory_items:
            if hasattr(item, 'type') and item.type == "video_segments":
                all_segments.extend(item.content)
        
        # Format sources with relevant information
        sources = []
        for segment in all_segments[:5]:  # Limit to top 5 segments
            try:
                sources.append({
                    "video_title": segment.video_title,
                    "url": segment.url,
                    "timestamp": int(segment.start_time),
                    "text": segment.text
                })
            except Exception as e:
                log("action", f"Error formatting segment as source: {e}")
        
        return SearchResult(
            answer=generated_text,
            sources=sources
        ) 
    
    def generate_response(self, decision: DecisionResult, memory_items: List[MemoryItem]) -> ActionResult:
        """
        Generate a response based on the decision and memory items.
        
        Args:
            decision: The decision result from the Decision component
            memory_items: List of memory items from the Memory component
            
        Returns:
            ActionResult object containing the response
        """
        log("action", "Generating response")
        start_time = time.time()
        
        if not decision:
            logger.error("No decision provided for response generation")
            return ActionResult(
                response="I couldn't process that request. Please try again.",
                video_segments=[]
            )
            
        if not memory_items:
            logger.warning("No memory items available for response generation")
            return ActionResult(
                response="I couldn't find any relevant information in the video. Please try a different question or check if the video has been indexed.",
                video_segments=[]
            )
            
        log("action", f"Decision intent: {decision.intent}")
        log("action", f"Decision plan: {decision.plan}")
        log("action", f"Memory items count: {len(memory_items)}")
        
        relevant_segments = []
        
        # Extract video segments from memory items
        for item in memory_items:
            log("action", f"Processing memory item of type: {item.type}")
            
            if item.type == "video_segments":
                segments = item.content
                log("action", f"Found {len(segments)} video segments")
                
                # Sort segments by relevance (score)
                segments.sort(key=lambda x: x.score if hasattr(x, 'score') else 0, reverse=True)
                
                for i, segment in enumerate(segments[:3]):  # Log top 3 segments
                    if hasattr(segment, 'score'):
                        log("action", f"Segment {i+1}: score={segment.score:.4f}, time={segment.start_time}s-{segment.end_time}s")
                    else:
                        log("action", f"Segment {i+1}: time={segment.start_time}s-{segment.end_time}s (no score)")
                
                relevant_segments.extend(segments)
        
        # Determine response based on intent
        log("action", f"Constructing response for intent: {decision.intent}")
        response = self._create_response(decision, relevant_segments)
        
        # Package results
        result = ActionResult(
            response=response,
            video_segments=relevant_segments[:5]  # Limit to top 5 segments
        )
        
        end_time = time.time()
        log("action", f"Response generation completed in {end_time - start_time:.3f} seconds")
        log("action", f"Response length: {len(response)} characters")
        log("action", f"Included {len(result.video_segments)} video segments in result")
        
        return result
    
    def _create_response(self, decision: DecisionResult, segments: List) -> str:
        """
        Create a response based on the decision and segments.
        
        Args:
            decision: Decision result
            segments: List of video segments
            
        Returns:
            Formatted response string
        """
        log("action", f"Creating response for intent: {decision.intent}")
        start_time = time.time()
        
        if not segments:
            logger.warning("No segments available for response creation")
            return "I couldn't find any relevant information in this video. Please try a different question."
        
        intent = decision.intent
        response_text = ""
        
        try:
            if intent == "find_quote" or intent == "locate_information":
                log("action", "Handling find_quote/locate_information intent")
                
                # For quote finding, we use the most relevant segment
                best_segment = segments[0]
                response_text = f"Here's what I found in the video: \"{best_segment.text}\""
                
                # Add timestamp information
                minutes, seconds = divmod(int(best_segment.start_time), 60)
                timestamp = f"{minutes}:{seconds:02d}"
                response_text += f" (at {timestamp})"
                
                log("action", f"Created quote response with timestamp {timestamp}")
                
            elif intent == "explain_topic" or intent == "find_definition":
                log("action", "Handling explain_topic/find_definition intent")
                
                # For explanations, we combine information from multiple segments
                explanation = ""
                for i, segment in enumerate(segments[:3]):  # Use top 3 segments
                    explanation += segment.text + " "
                    log("action", f"Added segment {i+1} to explanation (length: {len(segment.text)} chars)")
                
                response_text = f"Based on the video, {explanation.strip()}"
                log("action", f"Created explanation response of {len(response_text)} characters")
                
            elif intent == "summarize_content":
                log("action", "Handling summarize_content intent")
                
                # For summaries, use several segments but more concisely
                summary_parts = []
                for i, segment in enumerate(segments[:4]):  # Use top 4 segments
                    summary_parts.append(segment.text)
                    log("action", f"Added segment {i+1} to summary (length: {len(segment.text)} chars)")
                
                combined_text = " ".join(summary_parts)
                response_text = f"To summarize what's discussed in the video: {combined_text}"
                log("action", f"Created summary response of {len(response_text)} characters")
                
            else:
                log("action", f"Handling generic/unknown intent: {intent}")
                
                # Generic response for other intents
                best_segment = segments[0]
                response_text = f"From the video: {best_segment.text}"
                log("action", "Created generic response")
        
        except Exception as e:
            logger.error(f"Error creating response: {str(e)}", exc_info=True)
            response_text = "I found some information in the video but had trouble formatting it. Here's the relevant part: "
            
            # Fallback to using first segment
            if segments:
                response_text += segments[0].text
        
        end_time = time.time()
        log("action", f"Response creation completed in {end_time - start_time:.3f} seconds")
        
        return response_text 